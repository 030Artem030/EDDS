import json
import os
import asyncio
from aiogram import Bot, Dispatcher, F, types
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.enums import ContentType
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.filters import StateFilter
from aiogram.utils.keyboard import InlineKeyboardBuilder

API_TOKEN = '7679712644:AAH9n2-tGOYnATUqk7eTKDj0UfmsG4sOSmk'
ADMIN_ID = 6246062168
USERS_FILE = 'users.json'
GROUPS = ["–†—É–∫–æ–≤–æ–¥—è—â–∏–π —Å–æ—Å—Ç–∞–≤üßë‚Äçüíº", "–ö–ß–°üå™Ô∏è", "–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ –ï–î–î–°üßë‚Äçüíª"]

bot = Bot(token=API_TOKEN)
dp = Dispatcher(storage=MemoryStorage())

# --- –°–æ—Å—Ç–æ—è–Ω–∏—è ---
class BroadcastStates(StatesGroup):
    await_broadcast = State()

class ReplyToAdminStates(StatesGroup):
    waiting_for_reply = State()

# --- –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ---
def load_users():
    if not os.path.exists(USERS_FILE):
        return {}
    with open(USERS_FILE, 'r') as f:
        return json.load(f)

def save_users(users):
    with open(USERS_FILE, 'w') as f:
        json.dump(users, f)

def register_user(user_id):
    users = load_users()
    if str(user_id) not in users:
        users[str(user_id)] = None
        save_users(users)

def set_user_group(user_id, group):
    users = load_users()
    users[str(user_id)] = group
    save_users(users)

def get_user_group(user_id):
    return load_users().get(str(user_id))

def get_users_by_group(group):
    return [int(uid) for uid, g in load_users().items() if g == group]

# --- –ö–æ–º–∞–Ω–¥—ã ---
@dp.message(F.text == "/start")
async def start(message: Message):
    register_user(message.from_user.id)
    await message.answer("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã‚úÖ. –û–∂–∏–¥–∞–π—Ç–µ, –ø–æ–∫–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –¥–æ–±–∞–≤–∏—Ç –≤–∞—Å –≤ –≥—Ä—É–ø–ø—É.")

@dp.message(F.text == "/mygroup")
async def my_group(message: Message):
    group = get_user_group(message.from_user.id)
    if group:
        await message.answer(f"–í–∞—à–∞ –≥—Ä—É–ø–ø–∞: {group}")
    else:
        await message.answer("–í—ã –µ—â—ë –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –≥—Ä—É–ø–ø—É.")

@dp.message(F.text == "/users")
async def list_users(message: Message):
    if message.from_user.id != ADMIN_ID:
        return
    users = load_users()
    for uid, group in users.items():
        group_text = group if group else "–ë–µ–∑ –≥—Ä—É–ø–ø—ã"
        try:
            user = await bot.get_chat(int(uid))
            name = f"{user.full_name} (@{user.username})" if user.username else user.full_name
        except:
            name = f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–º—è (ID: {uid})"

        keyboard = InlineKeyboardBuilder()
        for idx, g in enumerate(GROUPS):
            keyboard.button(text=f"–î–æ–±–∞–≤–∏—Ç—å –≤ '{g}'", callback_data=f"addgroup:{uid}:{idx}")
        keyboard.button(text="‚ùå –£–¥–∞–ª–∏—Ç—å –∏–∑ –≥—Ä—É–ø–ø—ã", callback_data=f"removegroup:{uid}")
        keyboard.adjust(1)

        await message.answer(f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {name}\nüìå –ì—Ä—É–ø–ø–∞: {group_text}", reply_markup=keyboard.as_markup())

@dp.callback_query(F.data.startswith("addgroup:"))
async def add_group_callback(callback: CallbackQuery):
    _, uid, group_index = callback.data.split(":")
    group = GROUPS[int(group_index)]
    set_user_group(uid, group)
    await callback.answer("–ì—Ä—É–ø–ø–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞")
    await callback.message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä—É–ø–ø—É: {group}")

@dp.callback_query(F.data.startswith("removegroup:"))
async def remove_group_callback(callback: CallbackQuery):
    uid = callback.data.split(":")[1]
    set_user_group(uid, None)
    await callback.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω –∏–∑ –≥—Ä—É–ø–ø—ã")
    await callback.message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} —É–¥–∞–ª—ë–Ω –∏–∑ –≥—Ä—É–ø–ø—ã")

@dp.message(F.text == "/broadcast")
async def broadcast_menu(message: Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        return
    keyboard = InlineKeyboardBuilder()
    for group in GROUPS:
        keyboard.button(text=group, callback_data=f"broadcast:{group}")
    keyboard.adjust(1)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:", reply_markup=keyboard.as_markup())

@dp.callback_query(F.data.startswith("broadcast:"))
async def broadcast_choose(callback: CallbackQuery, state: FSMContext):
    group = callback.data.split(":")[1]
    await state.set_data({"group": group})
    await callback.message.answer(f"–ü—Ä–∏—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –º–µ–¥–∏–∞ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –≤ –≥—Ä—É–ø–ø—É: {group}")
    await state.set_state(BroadcastStates.await_broadcast)
    await callback.answer()

@dp.message(StateFilter(BroadcastStates.await_broadcast))
async def handle_broadcast_content(message: Message, state: FSMContext):
    data = await state.get_data()
    group = data.get("group")
    user_ids = get_users_by_group(group)
    success = 0

    reply_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ù–µ —Å–º–æ–≥—É –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å", callback_data="reply_admin")]
    ])

    for uid in user_ids:
        try:
            if message.text:
                await bot.send_message(uid, message.text, reply_markup=reply_keyboard)
            elif message.photo:
                await bot.send_photo(uid, message.photo[-1].file_id, caption=message.caption, reply_markup=reply_keyboard)
            elif message.video:
                await bot.send_video(uid, message.video.file_id, caption=message.caption, reply_markup=reply_keyboard)
            elif message.document:
                await bot.send_document(uid, message.document.file_id, caption=message.caption, reply_markup=reply_keyboard)
            success += 1
        except:
            continue

    await message.answer(f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –£—Å–ø–µ—à–Ω–æ: {success}/{len(user_ids)}")
    await state.clear()

@dp.callback_query(F.data == "reply_admin")
async def start_reply(callback: CallbackQuery, state: FSMContext):
    await state.set_state(ReplyToAdminStates.waiting_for_reply)
    await state.set_data({"from_user": callback.from_user.id})
    await callback.message.answer("‚úçÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    await callback.answer()

@dp.message(StateFilter(ReplyToAdminStates.waiting_for_reply))
async def send_reply_to_admin(message: Message, state: FSMContext):
    data = await state.get_data()
    from_user_id = data.get("from_user")
    try:
        user = await bot.get_chat(from_user_id)
        sender = f"{user.full_name} (@{user.username})" if user.username else user.full_name
    except:
        sender = f"ID: {from_user_id}"

    await bot.send_message(ADMIN_ID, f"üì© –û—Ç–≤–µ—Ç –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {sender}:\n{message.text}")
    await message.answer("‚úÖ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
    await state.clear()

# --- –ó–∞–ø—É—Å–∫ ---
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())